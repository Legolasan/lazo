/* automatically generated by JSCoverage - do not edit */
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    _$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (typeof _$jscoverage !== 'object') {
  _$jscoverage = {};
}
if (! _$jscoverage['server/serviceProxy.js']) {
  _$jscoverage['server/serviceProxy.js'] = [];
  _$jscoverage['server/serviceProxy.js'][1] = 0;
  _$jscoverage['server/serviceProxy.js'][7] = 0;
  _$jscoverage['server/serviceProxy.js'][15] = 0;
  _$jscoverage['server/serviceProxy.js'][31] = 0;
  _$jscoverage['server/serviceProxy.js'][32] = 0;
  _$jscoverage['server/serviceProxy.js'][34] = 0;
  _$jscoverage['server/serviceProxy.js'][35] = 0;
  _$jscoverage['server/serviceProxy.js'][38] = 0;
  _$jscoverage['server/serviceProxy.js'][39] = 0;
  _$jscoverage['server/serviceProxy.js'][40] = 0;
  _$jscoverage['server/serviceProxy.js'][41] = 0;
  _$jscoverage['server/serviceProxy.js'][42] = 0;
  _$jscoverage['server/serviceProxy.js'][46] = 0;
  _$jscoverage['server/serviceProxy.js'][69] = 0;
  _$jscoverage['server/serviceProxy.js'][70] = 0;
  _$jscoverage['server/serviceProxy.js'][71] = 0;
  _$jscoverage['server/serviceProxy.js'][74] = 0;
  _$jscoverage['server/serviceProxy.js'][75] = 0;
  _$jscoverage['server/serviceProxy.js'][76] = 0;
  _$jscoverage['server/serviceProxy.js'][77] = 0;
  _$jscoverage['server/serviceProxy.js'][78] = 0;
  _$jscoverage['server/serviceProxy.js'][82] = 0;
  _$jscoverage['server/serviceProxy.js'][90] = 0;
  _$jscoverage['server/serviceProxy.js'][108] = 0;
  _$jscoverage['server/serviceProxy.js'][109] = 0;
  _$jscoverage['server/serviceProxy.js'][110] = 0;
  _$jscoverage['server/serviceProxy.js'][113] = 0;
  _$jscoverage['server/serviceProxy.js'][114] = 0;
  _$jscoverage['server/serviceProxy.js'][115] = 0;
  _$jscoverage['server/serviceProxy.js'][116] = 0;
  _$jscoverage['server/serviceProxy.js'][117] = 0;
  _$jscoverage['server/serviceProxy.js'][121] = 0;
  _$jscoverage['server/serviceProxy.js'][129] = 0;
  _$jscoverage['server/serviceProxy.js'][147] = 0;
  _$jscoverage['server/serviceProxy.js'][148] = 0;
  _$jscoverage['server/serviceProxy.js'][149] = 0;
  _$jscoverage['server/serviceProxy.js'][152] = 0;
  _$jscoverage['server/serviceProxy.js'][153] = 0;
  _$jscoverage['server/serviceProxy.js'][154] = 0;
  _$jscoverage['server/serviceProxy.js'][155] = 0;
  _$jscoverage['server/serviceProxy.js'][156] = 0;
  _$jscoverage['server/serviceProxy.js'][160] = 0;
  _$jscoverage['server/serviceProxy.js'][172] = 0;
  _$jscoverage['server/serviceProxy.js'][173] = 0;
  _$jscoverage['server/serviceProxy.js'][175] = 0;
  _$jscoverage['server/serviceProxy.js'][177] = 0;
  _$jscoverage['server/serviceProxy.js'][178] = 0;
  _$jscoverage['server/serviceProxy.js'][183] = 0;
  _$jscoverage['server/serviceProxy.js'][184] = 0;
  _$jscoverage['server/serviceProxy.js'][185] = 0;
  _$jscoverage['server/serviceProxy.js'][188] = 0;
  _$jscoverage['server/serviceProxy.js'][190] = 0;
  _$jscoverage['server/serviceProxy.js'][194] = 0;
  _$jscoverage['server/serviceProxy.js'][195] = 0;
  _$jscoverage['server/serviceProxy.js'][199] = 0;
  _$jscoverage['server/serviceProxy.js'][200] = 0;
  _$jscoverage['server/serviceProxy.js'][204] = 0;
  _$jscoverage['server/serviceProxy.js'][210] = 0;
  _$jscoverage['server/serviceProxy.js'][211] = 0;
  _$jscoverage['server/serviceProxy.js'][214] = 0;
  _$jscoverage['server/serviceProxy.js'][217] = 0;
  _$jscoverage['server/serviceProxy.js'][220] = 0;
  _$jscoverage['server/serviceProxy.js'][221] = 0;
  _$jscoverage['server/serviceProxy.js'][223] = 0;
  _$jscoverage['server/serviceProxy.js'][224] = 0;
  _$jscoverage['server/serviceProxy.js'][225] = 0;
  _$jscoverage['server/serviceProxy.js'][226] = 0;
  _$jscoverage['server/serviceProxy.js'][229] = 0;
  _$jscoverage['server/serviceProxy.js'][230] = 0;
  _$jscoverage['server/serviceProxy.js'][233] = 0;
  _$jscoverage['server/serviceProxy.js'][234] = 0;
  _$jscoverage['server/serviceProxy.js'][238] = 0;
  _$jscoverage['server/serviceProxy.js'][245] = 0;
  _$jscoverage['server/serviceProxy.js'][251] = 0;
}
_$jscoverage['server/serviceProxy.js'].source = ["define(['base', 'request', 'underscore', 'resolver/model'], function(Base, request, _, helpers) {","","    /**","     * A utility class that can be used to call service endpoints.","     * @class ServiceProxy","     */","    var ServiceProxy = Base.extend({","","        /**","         * Constructor used internally.","         * @constructor","         * @private","         */","        constructor: function(ctx) {","            this.ctx = ctx;","        },","","        /**","         * Use to send a GET request to a service","         * @method get","         * @param {String} svc The url for a given service endpoint","         * @param {Object} options","         *      @param {Object} [options.params] A hash containing name-value pairs used in url substitution.","         *      @param {Function} options.success Callback function to be called when fetch succeeds, passed &lt;code&gt;(response)&lt;/code&gt; as argument.","         *      @param {Function} options.error Callback function to be called when fetch fails, passed &lt;code&gt;(response)&lt;/code&gt; as argument.","         *      @param {Object} [options.headers] A hash containing name-value pairs of headers to be sent to the service.","         *      @param {Boolean} [options.raw] A boolean that if set to true will return a unparsed response.","         * @async","         */","        get: function(svc, options) {","            options = options || {};","            options.raw = !!options.raw;","","            if (!options.success) {","                throw new Error('Success callback undefined for service call svc: ' + svc);","            }","","            var error = options.error;","            options.error = function(err) {","                LAZO.logger.log('error', 'ServiceProxy::error', 'get failed for ' + svc + ' ' + err.data, err);","                if (error) {","                    error(err);","                }","            };","            // use the backbone verbs","            this.sync(","                'read',","                {","                    name: svc,","                    url: svc,","                    params: options.params,","                    ctx: this.ctx","                },","                options);","        },","","        /**","         * Used to send a POST request to a service","         * @method post","         * @param {String} svc The url for a given service endpoint","         * @param {Object} attributes A hash containing name-value pairs used to be sent as the payload to the server","         * @param {Object} options","         *      @param {Object} [options.params] A hash containing name-value pairs used in url substitution.","         *      @param {Function} options.success Callback function to be called when fetch succeeds, passed &lt;code&gt;(response)&lt;/code&gt; as argument.","         *      @param {Function} options.error Callback function to be called when fetch fails, passed &lt;code&gt;(response)&lt;/code&gt; as argument.","         * @async","         */","        post: function(svc, attributes, options) {","            options = options || {};","            if (!options.success) {","                throw new Error('Success callback undefined for service call svc: ' + svc);","            }","","            var error = options.error;","            options.error = function(err) {","                LAZO.logger.log('error', 'ServiceProxy::error', 'post failed for ' + svc + ' ' + err.data, err);","                if (error) {","                    error(err);","                }","            };","            // use the backbone verbs","            this.sync(","                'create',","                {","                    name: svc,","                    url: svc,","                    params: options.params,","                    ctx: this.ctx,","                    toJSON: function() {","                        return attributes;","                    }","                },","                options);","        },","","        /**","         * Used to send a PUT request to a service","         * @method put","         * @param {String} svc The url for a given service endpoint","         * @param {Object} attributes A hash containing name-value pairs used to be sent as the payload to the server","         * @param {Object} options","         *      @param {Object} [options.params] A hash containing name-value pairs used in url substitution.","         *      @param {Function} options.success Callback function to be called when fetch succeeds, passed &lt;code&gt;(response)&lt;/code&gt; as argument.","         *      @param {Function} options.error Callback function to be called when fetch fails, passed &lt;code&gt;(response)&lt;/code&gt; as argument.","         * @async","         */","        put: function(svc, attributes, options) {","            options = options || {};","            if (!options.success) {","                throw new Error('Success callback undefined for service call svc: ' + svc);","            }","","            var error = options.error;","            options.error = function(err) {","                LAZO.logger.log('error', 'ServiceProxy::error', 'put failed for ' + svc + ' ' + err.data, err);","                if (error) {","                    error(err);","                }","            };","            // use the backbone verbs","            this.sync(","                'update',","                {","                    name: svc,","                    url: svc,","                    params: options.params,","                    ctx: this.ctx,","                    toJSON: function() {","                        return attributes;","                    }","                },","                options);","        },","","        /**","         * Used to send a DELETE request to a service","         * @method destroy","         * @param {String} svc The url for a given service endpoint","         * @param {Object} attributes A hash containing name-value pairs used to be sent as the payload to the server","         * @param {Object} options","         *      @param {Object} [options.params] A hash containing name-value pairs used in url substitution.","         *      @param {Function} options.success Callback function to be called when fetch succeeds, passed &lt;code&gt;(response)&lt;/code&gt; as argument.","         *      @param {Function} options.error Callback function to be called when fetch fails, passed &lt;code&gt;(response)&lt;/code&gt; as argument.","         * @async","         */","        destroy: function(svc, attributes, options) {","            options = options || {};","            if (!options.success) {","                throw new Error('Success callback undefined for service call svc: ' + svc);","            }","","            var error = options.error;","            options.error = function(err) {","                LAZO.logger.log('error', 'ServiceProxy::error', 'delete failed for ' + svc + ' ' + err.data, err);","                if (error) {","                    error(err);","                }","            };","            // use the backbone verbs","            this.sync(","                'delete',","                {","                    name: svc,","                    url: svc,","                    params: options.params,","                    ctx: this.ctx","                },","                options);","        },","","        sync: function(method, model, options) {","            options = _(options).clone();","            method = helpers.methodMap[method]; // convert backbone verbs to http","","            try {","","                var errorWrapper = function (err, response, body) {","                    var resp = {","                        statusCode: (response &amp;&amp; response.statusCode ? response.statusCode : 500),","                        headers: (response &amp;&amp; response.headers ? response.headers : {}),","                        body: body","                    };","                    response = response || {};","                    if (err instanceof Error) {","                        resp.error = err.message;","                    }","                    else {","                        resp.error = err;","                    }","                    options.error(resp);","","                };","                ","                if (model._default) {","                    throw new Error('No model defined in repo for ' + model.name);","                }","","                // throw error if no url","                if (!model.urlRoot &amp;&amp; !model.url) {","                    throw new Error('Error: ServiceProxy failed.  No url or urlRoot for ' + model.name + ' type: ' + method);","                }","","                // setup options for request call","                var requestOptions = {","                        method: method,","                        headers: options.headers ? options.headers : {},","                        timeout: options.timeout || 30000","                    };","","                if (method === 'POST' || method === 'PUT' || method === 'PATCH') {","                    requestOptions.body = model.toJSON(options);","                }","","                requestOptions.uri = helpers.substitute(_.result(model, 'url'), model.params);","","                // make the request","                request(requestOptions, ","                    function (error, response, body) {","                    ","                        if (error) {","                            return errorWrapper(error, response, body);","                        }","                        else if (response &amp;&amp; (response.statusCode &amp;&amp; response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 || response.statusCode === 304)) {","                            var data = body || '';","                            if (!options.raw) {","                                data = JSON.parse(body);","                            }","","                            if (response.headers) {","                                model.responseHeaders = response.headers;","                            }","","                            if (options.success) {","                                return options.success(data);","                            }","                        }","                        else {","                            return errorWrapper(new Error(response.statusCode), response, body);","                        }","                        ","                    }","                );","                ","            } catch (e) {","                errorWrapper(e, {}, '');","            }","        }","","    });","","    return ServiceProxy;","});"];
_$jscoverage['server/serviceProxy.js'][1]++;
define(["base", "request", "underscore", "resolver/model"], (function (Base, request, _, helpers) {
  _$jscoverage['server/serviceProxy.js'][7]++;
  var ServiceProxy = Base.extend({constructor: (function (ctx) {
  _$jscoverage['server/serviceProxy.js'][15]++;
  this.ctx = ctx;
}), get: (function (svc, options) {
  _$jscoverage['server/serviceProxy.js'][31]++;
  options = (options || {});
  _$jscoverage['server/serviceProxy.js'][32]++;
  options.raw = (! (! options.raw));
  _$jscoverage['server/serviceProxy.js'][34]++;
  if ((! options.success)) {
    _$jscoverage['server/serviceProxy.js'][35]++;
    throw new Error(("Success callback undefined for service call svc: " + svc));
  }
  _$jscoverage['server/serviceProxy.js'][38]++;
  var error = options.error;
  _$jscoverage['server/serviceProxy.js'][39]++;
  options.error = (function (err) {
  _$jscoverage['server/serviceProxy.js'][40]++;
  LAZO.logger.log("error", "ServiceProxy::error", ("get failed for " + svc + " " + err.data), err);
  _$jscoverage['server/serviceProxy.js'][41]++;
  if (error) {
    _$jscoverage['server/serviceProxy.js'][42]++;
    error(err);
  }
});
  _$jscoverage['server/serviceProxy.js'][46]++;
  this.sync("read", {name: svc, url: svc, params: options.params, ctx: this.ctx}, options);
}), post: (function (svc, attributes, options) {
  _$jscoverage['server/serviceProxy.js'][69]++;
  options = (options || {});
  _$jscoverage['server/serviceProxy.js'][70]++;
  if ((! options.success)) {
    _$jscoverage['server/serviceProxy.js'][71]++;
    throw new Error(("Success callback undefined for service call svc: " + svc));
  }
  _$jscoverage['server/serviceProxy.js'][74]++;
  var error = options.error;
  _$jscoverage['server/serviceProxy.js'][75]++;
  options.error = (function (err) {
  _$jscoverage['server/serviceProxy.js'][76]++;
  LAZO.logger.log("error", "ServiceProxy::error", ("post failed for " + svc + " " + err.data), err);
  _$jscoverage['server/serviceProxy.js'][77]++;
  if (error) {
    _$jscoverage['server/serviceProxy.js'][78]++;
    error(err);
  }
});
  _$jscoverage['server/serviceProxy.js'][82]++;
  this.sync("create", {name: svc, url: svc, params: options.params, ctx: this.ctx, toJSON: (function () {
  _$jscoverage['server/serviceProxy.js'][90]++;
  return attributes;
})}, options);
}), put: (function (svc, attributes, options) {
  _$jscoverage['server/serviceProxy.js'][108]++;
  options = (options || {});
  _$jscoverage['server/serviceProxy.js'][109]++;
  if ((! options.success)) {
    _$jscoverage['server/serviceProxy.js'][110]++;
    throw new Error(("Success callback undefined for service call svc: " + svc));
  }
  _$jscoverage['server/serviceProxy.js'][113]++;
  var error = options.error;
  _$jscoverage['server/serviceProxy.js'][114]++;
  options.error = (function (err) {
  _$jscoverage['server/serviceProxy.js'][115]++;
  LAZO.logger.log("error", "ServiceProxy::error", ("put failed for " + svc + " " + err.data), err);
  _$jscoverage['server/serviceProxy.js'][116]++;
  if (error) {
    _$jscoverage['server/serviceProxy.js'][117]++;
    error(err);
  }
});
  _$jscoverage['server/serviceProxy.js'][121]++;
  this.sync("update", {name: svc, url: svc, params: options.params, ctx: this.ctx, toJSON: (function () {
  _$jscoverage['server/serviceProxy.js'][129]++;
  return attributes;
})}, options);
}), destroy: (function (svc, attributes, options) {
  _$jscoverage['server/serviceProxy.js'][147]++;
  options = (options || {});
  _$jscoverage['server/serviceProxy.js'][148]++;
  if ((! options.success)) {
    _$jscoverage['server/serviceProxy.js'][149]++;
    throw new Error(("Success callback undefined for service call svc: " + svc));
  }
  _$jscoverage['server/serviceProxy.js'][152]++;
  var error = options.error;
  _$jscoverage['server/serviceProxy.js'][153]++;
  options.error = (function (err) {
  _$jscoverage['server/serviceProxy.js'][154]++;
  LAZO.logger.log("error", "ServiceProxy::error", ("delete failed for " + svc + " " + err.data), err);
  _$jscoverage['server/serviceProxy.js'][155]++;
  if (error) {
    _$jscoverage['server/serviceProxy.js'][156]++;
    error(err);
  }
});
  _$jscoverage['server/serviceProxy.js'][160]++;
  this.sync("delete", {name: svc, url: svc, params: options.params, ctx: this.ctx}, options);
}), sync: (function (method, model, options) {
  _$jscoverage['server/serviceProxy.js'][172]++;
  options = _(options).clone();
  _$jscoverage['server/serviceProxy.js'][173]++;
  method = helpers.methodMap[method];
  _$jscoverage['server/serviceProxy.js'][175]++;
  try {
    _$jscoverage['server/serviceProxy.js'][177]++;
    var errorWrapper = (function (err, response, body) {
  _$jscoverage['server/serviceProxy.js'][178]++;
  var resp = {statusCode: ((response && response.statusCode)? response.statusCode: 500), headers: ((response && response.headers)? response.headers: {}), body: body};
  _$jscoverage['server/serviceProxy.js'][183]++;
  response = (response || {});
  _$jscoverage['server/serviceProxy.js'][184]++;
  if ((err instanceof Error)) {
    _$jscoverage['server/serviceProxy.js'][185]++;
    resp.error = err.message;
  }
  else {
    _$jscoverage['server/serviceProxy.js'][188]++;
    resp.error = err;
  }
  _$jscoverage['server/serviceProxy.js'][190]++;
  options.error(resp);
});
    _$jscoverage['server/serviceProxy.js'][194]++;
    if (model._default) {
      _$jscoverage['server/serviceProxy.js'][195]++;
      throw new Error(("No model defined in repo for " + model.name));
    }
    _$jscoverage['server/serviceProxy.js'][199]++;
    if (((! model.urlRoot) && (! model.url))) {
      _$jscoverage['server/serviceProxy.js'][200]++;
      throw new Error(("Error: ServiceProxy failed.  No url or urlRoot for " + model.name + " type: " + method));
    }
    _$jscoverage['server/serviceProxy.js'][204]++;
    var requestOptions = {method: method, headers: (options.headers? options.headers: {}), timeout: (options.timeout || 30000)};
    _$jscoverage['server/serviceProxy.js'][210]++;
    if (((method === "POST") || (method === "PUT") || (method === "PATCH"))) {
      _$jscoverage['server/serviceProxy.js'][211]++;
      requestOptions.body = model.toJSON(options);
    }
    _$jscoverage['server/serviceProxy.js'][214]++;
    requestOptions.uri = helpers.substitute(_.result(model, "url"), model.params);
    _$jscoverage['server/serviceProxy.js'][217]++;
    request(requestOptions, (function (error, response, body) {
  _$jscoverage['server/serviceProxy.js'][220]++;
  if (error) {
    _$jscoverage['server/serviceProxy.js'][221]++;
    return errorWrapper(error, response, body);
  }
  else {
    _$jscoverage['server/serviceProxy.js'][223]++;
    if ((response && ((response.statusCode && (response.statusCode >= 200) && (response.statusCode < 300)) || (response.statusCode === 304)))) {
      _$jscoverage['server/serviceProxy.js'][224]++;
      var data = (body || "");
      _$jscoverage['server/serviceProxy.js'][225]++;
      if ((! options.raw)) {
        _$jscoverage['server/serviceProxy.js'][226]++;
        data = JSON.parse(body);
      }
      _$jscoverage['server/serviceProxy.js'][229]++;
      if (response.headers) {
        _$jscoverage['server/serviceProxy.js'][230]++;
        model.responseHeaders = response.headers;
      }
      _$jscoverage['server/serviceProxy.js'][233]++;
      if (options.success) {
        _$jscoverage['server/serviceProxy.js'][234]++;
        return options.success(data);
      }
    }
    else {
      _$jscoverage['server/serviceProxy.js'][238]++;
      return errorWrapper(new Error(response.statusCode), response, body);
    }
  }
}));
  }
  catch (e) {
    _$jscoverage['server/serviceProxy.js'][245]++;
    errorWrapper(e, {}, "");
  }
})});
  _$jscoverage['server/serviceProxy.js'][251]++;
  return ServiceProxy;
}));
